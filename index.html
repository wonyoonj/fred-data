<!DOCTYPE html>
<html>
<head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background: #f4f4f4; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; position: relative; min-height: 10vh; }
        .header { text-align: center; padding: 10px; background: #007bff; color: white; }
        .back-btn { position: absolute; top: 10px; left: 10px; background: none; border: none; cursor: pointer; font-size: 24px; font-weight: bold; color: black; width: 30px; text-align: center; }
        .back-btn::before { content: "◄"; font-size: 36px; }
        .info-btn { position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; font-size: 20px; }
        .button { padding: 10px 20px; background: #007bff; color: white; border: none; cursor: pointer; }
        .button:hover { background: #0056b3; }

        #liquidityFlow {
            text-align: center;
            padding: 20px;
            position: relative;
            height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #liquidityFlow .icon-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transform: translate(-50%, -50%);
        }
        #liquidityFlow .icon {
            width: 80px;
            height: 80px;
            display: block;
            object-fit: contain;
        }
        #liquidityFlow .icon-label {
            font-weight: bold;
            color: black;
            font-size: 14px;
            white-space: nowrap;
            margin-top: 5px;
        }

        .FED-container .icon-label {
            order: -1;
            margin-bottom: 5px;
            margin-top: 0;
        }

        .FED-container { top: 20%; left: 50%; }
        .Government-container { top: 50%; left: 20%; }
        .Market-container { top: 80%; left: 50%; }
        .MMF-container { top: 50%; left: 80%; }

        #tgaSlopeDisplay, #fedLiquidityDisplay, #mmfToRrpDisplay, #mmfToMarketDisplay {
            position: absolute;
            transform: translateX(-50%);
            font-size: 0.8em;
            font-weight: bold;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 3px 6px;
            border-radius: 5px;
            border: 1px solid #ccc;
            text-align: center;
        }
        
        /* 팝업 컨테이너 및 팝업 스타일 */
        .tga-popup-container {
            position: absolute;
            top: calc(50% + 80px + 14px + 10px);
            left: 20%;
            transform: translateX(-50%);
            z-index: 20;
        }

        #tgaSlopeDisplay, .fed-popup-container, .mmf-fed-popup-container, .mmf-market-popup-container {
            position: relative;
            z-index: 10;
            cursor: help;
        }
        
        .fed-popup-container {
            top: calc(50% - 80px - 10px);
            left: 35%;
        }

        .mmf-fed-popup-container {
            top: calc(50% - 80px - 10px); /* MMF 아이콘 위에 위치 */
            left: 70%;
        }
        .mmf-market-popup-container {
            top: calc(50% + 80px + 14px + 10px); /* MMF 아이콘과 라벨 아래에 위치 */
            left: 80%;
            transform: translateX(-50%);
        }

        .tga-tooltip, .fed-tooltip, .mmf-fed-tooltip, .mmf-market-tooltip {
            visibility: hidden;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 100%; /* TGA 잔고 위에 위치 */
            left: 50%;
            margin-left: -100px; /* 중앙 정렬 */
            width: 180px;
            opacity: 0;
            transition: opacity 0.3s;
            line-height: 1.5;
            white-space: normal;
        }
        .tga-tooltip p, .fed-tooltip p, .mmf-fed-tooltip p, .mmf-market-tooltip p {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: normal;
        }
        .tga-tooltip .graph-btn, .fed-tooltip .graph-btn, .mmf-fed-tooltip .graph-btn, .mmf-market-tooltip .graph-btn {
            background: #009688;
            color: white;
            border: none;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 12px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 3px;
        }
        .tga-tooltip::after, .fed-tooltip::after, .mmf-fed-tooltip::after, .mmf-market-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
        .tga-popup-container:hover .tga-tooltip,
        .fed-popup-container:hover .fed-tooltip,
        .mmf-fed-popup-container:hover .mmf-fed-tooltip,
        .mmf-market-popup-container:hover .mmf-market-tooltip {
            visibility: visible;
            opacity: 1;
        }

        #fedLiquidityDisplay {
            position: relative;
        }
        
        #mmfToRrpDisplay {
            position: relative;
        }

        #mmfToMarketDisplay {
            position: relative;
        }

        .slope-positive { color: red; }
        .slope-negative { color: blue; }

        .dollar-animated-object {
            position: absolute;
            object-fit: contain;
            opacity: 0;
            z-index: 5;
        }

        /* 기존 애니메이션 */
        @keyframes dollarFlowToMarket {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 20%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 20%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
        }

        @keyframes dollarFlowToFED {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 20%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 20%; }
        }

        @keyframes dollarFlowToGovernment {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 20%; top: 50%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 20%; top: 50%; }
        }

        @keyframes dollarFlowFromGovernment {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 20%; top: 50%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 20%; top: 50%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
        }

        /* 신규 MMF 애니메이션 */
        @keyframes dollarFlowFromMmfToFed {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 20%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 20%; }
        }
        @keyframes dollarFlowFromFedToMmf {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 20%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 20%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
        }
        
        @keyframes dollarFlowFromMmfToMarket_parabolic {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            50% { transform: translate(-50%, -50%) scale(1) translateY(50px); opacity: 1; left: 65%; top: 65%; } 
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
        }
        @keyframes dollarFlowFromMarketToMmf_parabolic {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 50%; top: 80%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 50%; top: 80%; }
            50% { transform: translate(-50%, -50%) scale(1) translateY(50px); opacity: 1; left: 65%; top: 65%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
        }

        @keyframes dollarFlowFromMmfToGovernment {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 20%; top: 50%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 20%; top: 50%; }
        }
        @keyframes dollarFlowFromGovernmentToMmf {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 20%; top: 50%; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 20%; top: 50%; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; left: 80%; top: 50%; }
            100% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; left: 80%; top: 50%; }
        }


        .animated-dollar-to-market { animation: dollarFlowToMarket var(--animation-duration) linear forwards; }
        .animated-dollar-to-fed { animation: dollarFlowToFED var(--animation-duration) linear forwards; }
        .animated-dollar-to-government { animation: dollarFlowToGovernment var(--animation-duration) linear forwards; }
        .animated-dollar-from-government { animation: dollarFlowFromGovernment var(--animation-duration) linear forwards; }
        
        .animated-dollar-from-mmf-to-fed { animation: dollarFlowFromMmfToFed var(--animation-duration) linear forwards; }
        .animated-dollar-from-fed-to-mmf { animation: dollarFlowFromFedToMmf var(--animation-duration) linear forwards; }
        
        .animated-dollar-from-mmf-to-market_parabolic { animation: dollarFlowFromMmfToMarket_parabolic var(--animation-duration) linear forwards; }
        .animated-dollar-from-market-to-mmf_parabolic { animation: dollarFlowFromMarketToMmf_parabolic var(--animation-duration) linear forwards; }

        #graphIndicators { padding: 20px; text-align: center; }
        .indicator-section { margin-bottom: 20px; }
        .indicator-section h3 { font-size: 18px; margin-bottom: 10px; color: #007bff; }
        .indicator-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }

        #graphPage {
            text-align: center;
            padding: 20px;
            height: 500px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #graphPage canvas {
            max-width: 100%;
            width: 100%;
            height: 400px;
            cursor: grab;
            flex-grow: 1;
        }

        #infoPage { padding: 20px; text-align: center; }
        .time-buttons { margin: 10px 0; display: flex; justify-content: center; gap: 5px; flex-wrap: wrap; }
        .time-btn { padding: 5px 10px; background: #e9ecef; border: 1px solid #ced4da; border-radius: 5px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s; }
        .time-btn:hover { background-color: #dee2e6; }
        .nav-bar { position: fixed; bottom: 0; left: 0; width: 100%; background: #007bff; padding: 10px; display: flex; justify-content: space-around; }

        @media (max-width: 600px) {
            .container { padding: 10px; }
            .back-btn { top: 5px; left: 5px; }
            .info-btn { top: 5px; right: 5px; }

            #liquidityFlow .icon { width: 60px; height: 60px; }
            #liquidityFlow .icon-label { font-size: 12px; }

            .FED-container { top: 15%; left: 50%; }
            .Government-container { top: 40%; left: 15%; }
            .Market-container { top: 85%; left: 50%; }
            .MMF-container { top: 40%; left: 85%; }

            #tgaSlopeDisplay, #fedLiquidityDisplay, #mmfToRrpDisplay, #mmfToMarketDisplay {
                font-size: 0.7em;
                padding: 2px 4px;
                white-space: normal;
            }

            .tga-popup-container {
                top: calc(40% + 60px + 12px + 15px);
                left: 15%;
            }
            .tga-tooltip {
                margin-left: -100px;
                width: 200px;
            }
            .fed-popup-container {
                top: calc(15% + 60px + 12px + 15px);
                left: 50%;
            }

            #fedLiquidityDisplay { top: calc(40% + 60px + 12px + 35px); left: 15%; }
            #mmfToRrpDisplay { top: calc(40% - 60px - 10px); left: 75%; }
            #mmfToMarketDisplay { top: calc(40% + 60px + 12px + 15px); left: 85%; }
            
            .dollar-animated-object {
                width: 22.5px;
                height: 22.5px;
            }

            .indicator-buttons { grid-template-columns: 1fr; max-width: 100%; }
            .button { margin: 5px 0; }
            .time-buttons { justify-content: space-around; }
            .time-btn {
                padding: 5px 8px;
                font-size: 0.85em;
                margin: 2px;
                flex-basis: auto;
                width: auto;
            }
            #graphPage canvas {
                width: 100%;
                height: 300px;
            }
            .nav-bar { padding: 5px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>
    <div class="container">
        <div id="liquidityFlow" class="page">
            <div class="tga-popup-container">
                <div id="tgaSlopeDisplay"></div>
                <div class="tga-tooltip">
                    <p>최근 한 달 동안, 미국 재무부 잔고 변화를 나타냅니다.</p>
                    <p>+양수 : 시장에서 재무부로 달러 유동성 흡수</p>
                    <p>-음수 : 미국 재무부가 시장에 달러 유동성 공급</p>
                    <button class="graph-btn" onclick="showGraph('WTREGEN')">그래프</button>
                    <div id="tgaUpdateDate" style="font-size: 10px; text-align: right; margin-top: 5px;"></div>
                </div>
            </div>
            
            <div class="fed-popup-container">
                <div id="fedLiquidityDisplay"></div>
                <div class="fed-tooltip">
                    <p>최근 한 달 동안, 부채를 제외한 연준의 순자산(국채+모기지채 등) 변화를 나타냅니다.</p>
                    <p>+양수 : 시장의 채권 등 자산 구매를 통해 달러를 시장에 공급</p>
                    <p>-음수 : 자산 매각을 통해 시중의 달러를 다시 회수 (긴축)</p>
                    <button class="graph-btn" onclick="showGraph('WALCL')">그래프</button>
                    <div id="fedUpdateDate" style="font-size: 10px; text-align: right; margin-top: 5px;"></div>
                </div>
            </div>

            <div class="mmf-fed-popup-container">
                <div id="mmfToRrpDisplay"></div>
                <div class="mmf-fed-tooltip">
                    <p>최근 한 달 동안, MMF가 연준에게 돈을 맡긴 자금의 양 변화를 나타냅니다.</p>
                    <p>+양수 : MMF가 연준에게 역레포 자금을 빌려줌</p>
                    <p>-음수 : 연준에게 빌려준 역레포 자금을 다시 회수</p>
                    <button class="graph-btn" onclick="showGraph('RRPONTSYD')">그래프</button>
                    <div id="mmfFedUpdateDate" style="font-size: 10px; text-align: right; margin-top: 5px;"></div>
                </div>
            </div>

            <div class="mmf-market-popup-container">
                <div id="mmfToMarketDisplay"></div>
                <div class="mmf-market-tooltip">
                    <p>최근 한 달 동안, MMF가 시장에 돈을 공급한 자금의 양 변화를 나타냅니다.</p>
                    <p>이 결과는 MMF가 시장에 공급한 유동성에서 시장이 MMF에 투자한 양을 뺀 결과입니다.</p>
                    <p>+양수 : MMF가 시장에 유동성 공급량이 큰 상황</p>
                    <p>-음수 : 시장이 MMF에 자금을 투자한 양이 큰 상황</p>
                    <div id="mmfMarketValues" style="margin-top: 10px; font-size: 11px;"></div>
                    <div id="mmfMarketUpdateDate" style="font-size: 10px; text-align: right; margin-top: 5px;"></div>
                </div>
            </div>
            
            <div class="icon-container FED-container">
                <span class="icon-label">중앙은행 FED</span>
                <img src="./icon/fed.jpg" alt="FED" class="icon">
            </div>
            <div class="icon-container Government-container">
                <img src="./icon/government.JPG" alt="Government TGA" class="icon">
                <span class="icon-label">미국 정부</span>
            </div>
            <div class="icon-container Market-container">
                <img src="./icon/Market.jpg" alt="Market" class="icon">
                <span class="icon-label">미국 시장(Market)</span>
            </div>
            <div class="icon-container MMF-container">
                <img src="./icon/MMF.jpg" alt="MMF" class="icon">
                <span class="icon-label">MMF(Money Market Fund)</span>
            </div>
        </div>

        <div id="graphIndicators" class="page" style="display:none;">
            <div class="indicator-section">
                <h3>미국 자금 현황</h3>
                <div class="indicator-buttons">
                    <button class="button" onclick="showGraph('WTREGEN')">미 정부 TGA 잔고</button>
                    <button class="button" onclick="showGraph('WRESBAL')">미 은행 지급준비금</button>
                    <button class="button" onclick="showGraph('RRPONTSYD')">연준 역레포 자금</button>
                    <button class="button" onclick="showGraph('MMMFFAQ027S')">MMF 잔고</button>
                    <button class="button" onclick="showGraph('WALCL')">연준 전체 자산 + 부채</button>
                </div>
            </div>
            <div class="indicator-section">
                <h3>금리</h3>
                <div class="indicator-buttons">
                    <button class="button" onclick="showGraph('SOFR')">SOFR 금리</button>
                    <button class="button" onclick="showGraph('FEDFUNDS')">EFFR 금리</button>
                    <button class="button" onclick="showGraph('TB3MS')">3개월 미 국채금리</button>
                    <button class="button" onclick="showGraph('TB1YR')">1년물 미 국채금리</button>
                    <button class="button" onclick="showGraph('DPCREDIT')">연준 할인율</button>
                    <button class="button" onclick="showGraph('DRBLACBS')">미 은행 연체율(전체)</button>
                </div>
            </div>
            <div class="indicator-section">
                <h3>유동성</h3>
                <div class="indicator-buttons">
                    <button class="button" onclick="showGraph('M2SL')">M2</button>
                    <button class="button" onclick="showGraph('M1SL')">M1</button>
                </div>
            </div>
            <div class="indicator-section">
                <h3>자산 가격</h3>
                <div class="indicator-buttons">
                    <button class="button" onclick="showGraph('NASDAQ100')">나스닥100 지수</button>
                    <button class="button" onclick="showGraph('SP500')">S&P500 지수</button>
                    <button class="button" onclick="showGraph('SP500_MCAP')">S&P500 시가총액</button>
                </div>
            </div>
        </div>

        <div id="graphPage" class="page" style="display:none;">
            <button class="back-btn" onclick="showGraphIndicators()">◄</button>
            <button class="info-btn" onclick="showInfo()">Info</button>
            <h2 id="graphTitle"></h2>
            <canvas id="myChart"></canvas>
            <div class="time-buttons">
                <button class="time-btn" onclick="updateChart('1M')">1M</button>
                <button class="time-btn" onclick="updateChart('6M')">6M</button>
                <button class="time-btn" onclick="updateChart('1Y')">1Y</button>
                <button class="time-btn" onclick="updateChart('5Y')">5Y</button>
                <button class="time-btn" onclick="updateChart('10Y')">10Y</button>
                <button class="time-btn" onclick="updateChart('All')">All</button>
            </div>
        </div>

        <div id="infoPage" class="page" style="display:none;">
            <button class="back-btn" onclick="goBackToGraph()">◄</button>
            <h2 id="infoTitle"></h2>
            <div id="infoContent"></div>
        </div>

        <div class="nav-bar">
            <button class="button" onclick="showLiquidityFlow()">유동성 현황</button>
            <button class="button" onclick="showGraphIndicators()">그래프 지표</button>
        </div>
    </div>

    <script>
        let myChart = null;
        let isDragging = false;
        let startX;
        let startScrollX;
        let currentIndicator = null;
        let currentGraphData = [];
        let dollarAnimationIntervals = [];
        
        // --- 수정된 부분: 애니메이션 기준값 설정 ---
        const BASE_ANIMATION_DURATION = 3000;
        const BASE_DOLLAR_SIZE = 37.5; // 기본 달러 아이콘 크기
        const NUM_DOLLAR_ANIMATIONS = 3;

        const FUNCTION_BASE_URL = '/.netlify/functions/get-csv-data';

        const indicatorTitles = {
            'WTREGEN': '미 정부 TGA 잔고',
            'WRESBAL': '미 은행 지급준비금',
            'RRPONTSYD': '연준 역레포 자금',
            'MMMFFAQ027S': 'MMF 잔고',
            'WALCL': '연준 전체 자산 + 부채',
            'SOFR': 'SOFR 금리',
            'FEDFUNDS': 'EFFR 금리',
            'TB3MS': '3개월 미 국채금리',
            'TB1YR': '1년물 미 국채금리',
            'DPCREDIT': '연준 할인율',
            'DRBLACBS': '미 은행 연체율(전체)',
            'M2SL': 'M2',
            'M1SL': 'M1',
            'NASDAQ100': '나스닥100 지수',
            'SP500': 'S&P500 지수',
            'SP500_MCAP': 'S&P500 시가총액'
        };

        const indicatorUnits = {
            'WTREGEN': 'Billions of U.S. Dollars',
            'WRESBAL': 'Billions of Dollars',
            'RRPONTSYD': 'Billions of Dollars',
            'MMMFFAQ027S': 'Billions of Dollars',
            'WALCL': 'Billions of Dollars',
            'M2SL': 'Billions of Dollars',
            'M1SL': 'Billions of Dollars',
            'SP500_MCAP': 'Billions of Dollars',
            'SOFR': 'Percent (%)',
            'FEDFUNDS': 'Percent (%)',
            'TB3MS': 'Percent (%)',
            'TB1YR': 'Percent (%)',
            'DPCREDIT': 'Percent (%)',
            'DRBLACBS': 'Percent (%)',
            'NASDAQ100': 'Index',
            'SP500': 'Index'
        };

        async function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length <= 1) return [];

            const headers = lines[0].split(',').map(h => h.trim());
            
            let dateColIndex = headers.findIndex(h => h.toLowerCase() === 'date' || h.toLowerCase() === 'data');
            const valueColName = headers.find((h, i) => i !== dateColIndex);
            const valueColIdx = headers.indexOf(valueColName);

            if (dateColIndex === -1 || valueColIdx === -1) return [];

            const parsedData = [];
            for (let i = 1; i < lines.length; i++) {
                const columns = lines[i].split(',');
                if (columns.length > Math.max(dateColIndex, valueColIdx)) {
                    const dateStr = columns[dateColIndex].trim();
                    const valueStr = columns[valueColIdx].trim();

                    const dateObj = new Date(dateStr);
                    const valueNum = parseFloat(valueStr);

                    if (!isNaN(dateObj.getTime()) && !isNaN(valueNum) && valueStr !== '.') {
                        parsedData.push({ date: dateStr, value: valueNum });
                    }
                }
            }
            return parsedData;
        }

        window.addEventListener('load', () => showPage('liquidityFlow'));

        const pages = ['liquidityFlow', 'graphIndicators', 'graphPage', 'infoPage'];

        function showPage(pageId) {
            pages.forEach(id => document.getElementById(id).style.display = id === pageId ? 'block' : 'none');
            if (pageId === 'liquidityFlow') {
                updateLiquidityFlowAnimation();
            } else {
                stopLiquidityFlowAnimation();
            }
        }

        function showLiquidityFlow() { showPage('liquidityFlow'); }
        function showGraphIndicators() { showPage('graphIndicators'); }

        async function showGraph(indicator) {
            currentIndicator = indicator;
            showPage('graphPage');
            document.getElementById('graphTitle').textContent = indicatorTitles[indicator] || indicator;

            const functionUrl = `${FUNCTION_BASE_URL}?indicator=${indicator}`;

            try {
                renderErrorMessage("데이터를 불러오는 중...");
                const response = await fetch(functionUrl);
                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`'${indicatorTitles[indicator]}' 데이터를 찾을 수 없거나 불러오지 못했어요! (${response.status}: ${errorBody.error || response.statusText})`);
                }
                const text = await response.text();
                let data = await parseCSV(text);

                if (data.length === 0) {
                     renderErrorMessage(`'${indicatorTitles[indicator]}' 지표의 유효한 데이터가 없어요.`);
                     return;
                }
                
                data.forEach(item => {
                    if (indicator === 'WALCL') item.value /= 1000;
                    else if (indicator === 'MMMFFAQ027S' || indicator === 'SP500_MCAP') item.value /= 1000000000;
                });

                data.sort((a, b) => new Date(a.date) - new Date(b.date));

                currentGraphData = data;
                updateChart('All');

            } catch (error) {
                renderErrorMessage(`'${indicatorTitles[indicator]}' 그래프를 그릴 수 없어요! 오류: ${error.message}`);
            }
        }

        function renderChart(indicator, labels, values) {
            const ctx = document.getElementById('myChart').getContext('2d');
            if (myChart) myChart.destroy();

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: indicatorTitles[indicator] || indicator,
                        data: values,
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'month', tooltipFormat: 'yyyy-MM-dd', displayFormats: { day: 'yyyy-MM-dd', month: 'yyyy-MM', year: 'yyyy' }},
                            title: { display: true, text: 'Date' }
                        },
                        y: {
                            title: { display: true, text: indicatorUnits[indicator] || 'Value', font: { weight: 'bold' }},
                            ticks: {
                                callback: value => {
                                    if (Math.abs(value) >= 1e12) return (value / 1e12) + 'T';
                                    if (Math.abs(value) >= 1e9) return (value / 1e9) + 'B';
                                    if (Math.abs(value) >= 1e6) return (value / 1e6) + 'M';
                                    if (Math.abs(value) >= 1e3) return (value / 1e3) + 'K';
                                    return value;
                                }
                            }
                        }
                    },
                    plugins: { legend: { display: true }, tooltip: { mode: 'index', intersect: false } },
                    onHover: (event, chartElement) => { event.native.target.style.cursor = chartElement.length ? 'grab' : 'default'; }
                }
            });

            const canvas = document.getElementById('myChart');
            canvas.onmousedown = startDragging;
            canvas.onmousemove = drag;
            canvas.onmouseup = stopDragging;
            canvas.onmouseleave = stopDragging;
            canvas.onwheel = zoomChart;
        }

        function updateChart(range) {
            if (!currentGraphData || currentGraphData.length === 0) return;
            
            let dataToShow = [...currentGraphData];
            if (range !== 'All') {
                const lastDate = new Date(dataToShow[dataToShow.length - 1].date);
                const cutoff = new Date(lastDate);
                if (range === '1M') cutoff.setMonth(lastDate.getMonth() - 1);
                else if (range === '6M') cutoff.setMonth(lastDate.getMonth() - 6);
                else cutoff.setFullYear(lastDate.getFullYear() - { '1Y': 1, '5Y': 5, '10Y': 10 }[range]);
                dataToShow = dataToShow.filter(item => new Date(item.date) >= cutoff);
            }

            if (dataToShow.length > 0) {
                renderChart(currentIndicator, dataToShow.map(item => item.date), dataToShow.map(item => item.value));
            } else {
                renderErrorMessage('해당 기간의 데이터가 없어요!');
            }
        }

        function renderErrorMessage(message) {
            const ctx = document.getElementById('myChart').getContext('2d');
            if (myChart) myChart.destroy();
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function showInfo() {
            showPage('infoPage');
            const indicator = currentIndicator;
            const info = {
                'WTREGEN': {'title': '미 정부 TGA 잔고', 'content': {'경제적 의미': 'Treasury General Account (TGA)는 미국 정부의 현금 잔고 입니다. 이 잔고의 증가는 정부가 지출을 줄이거나 차입을 늘렸음을, 감소는 지출 증가나 상환을 의미할 수 있습니다.', '왜 필요한 지표인가': 'TGA 잔고는 유동성(시장에 순환하는 돈의 양)에 직접적인 영향을 미치며, 특히 연준의 통화 정책과 상호작용합니다. 잔고가 급격히 변동하면 단기 금리나 금융 시장 안정성에 영향을 줄 수 있어 모니터링이 필요합니다.'}},
                'WRESBAL': {'title': '미 은행 지급준비금', 'content': {'경제적 의미': '은행이 연방준비제도(FRB)에 예치한 의무적 예금으로, 은행 시스템의 유동성을 조절하는 데 사용됩니다. 이 수치가 높으면 은행이 대출을 줄일 가능성이 있고, 낮으면 대출이 증가할 수 있습니다.', '왜 필요한 지표인가': '지급준비금은 통화 공급량과 신용 창출에 영향을 미치며, 연준의 통화 정책(예: 양적 완화 또는 긴축)의 효과를 평가하는 데 핵심 지표입니다. 경제 과열이나 침체를 방지하기 위해 모니터링됩니다.'}},
                'M2SL': {'title': 'M2', 'content': {'경제적 의미': 'M2는 전통적인 은행 활동에 의한 화폐 공급량을 의미합니다. 예를 들면 은행에서의 현금, 수시입출금 예금, 저축 예금, 그리고 소액의 정기 예금을 포함합니다. 하지만 최근들어 MMF(Money Market Fund)의 자금 조달로 인한 M2에 간접적인 영향을 줄 수는 있겠으나, MMF 자금 유동성이 급격히 변동하더라도, M2 수치에 즉각적으로 반영되진 않을 수 있습니다. Stable Coin에 의한 자금 유동성 또한 M2에 직접 포함되지는 않습니다.', '왜 필요한 지표인가': 'M2는 전통적인 인플레이션, 경제 성장, 소비 동향을 예측하는 데 사용됩니다. 급격한 증가나 감소는 통화 정책 조정(예: 금리 인상/인하)의 신호로 해석될 수 있어 중요합니다.'}},
                'M1SL': {'title': 'M1', 'content': {'경제적 의미': 'M1은 화폐 공급량의 좁은 정의로, 현금과 수시입출금 예금을 포함합니다. 이는 가장 유동성이 높은 자산을 나타냅니다. M2와 마찬가지로 MMF와 Stable Coin에 의한 영향성은 제한적입니다.', '왜 필요한 지표인가': 'M1은 단기적인 지출 능력과 유동성 수준을 반영하며, 경제 활동의 초기 신호를 제공합니다. 특히 통화 정책의 실시간 영향을 분석하는 데 유용합니다.'}},
                'SOFR': {'title': 'SOFR 금리', 'content': {'경제적 의미': 'SOFR은 Secured Overnight Financing Rate의 약자로, 미국에서 한밤사이(overnight) 동안 담보(예: 미국 재무부 증권)를 기반으로 한 대출 거래의 이자율을 평균한 기준 금리입니다. 즉, SOFR은 은행이 다른 금융기관(예: 증권사, 헤지펀드 등)으로부터 담보를 제공하고 자금을 빌리는 비용을 나타냅니다.', '왜 필요한 지표인가': 'SOFR은 단기 자금 시장의 유동성과 수요-공급 상황을 반영합니다. 예를 들어, 시장에 자금이 부족하면 SOFR이 상승하고, 자금이 풍부하면 하락합니다. 이는 금융기관이 하루 동안 자금을 조달하거나 투자할 때 참고하는 중요한 기준 금리입니다. 시중에 자금이 넘치는지, 안넘치는지의 지표가 될 수 있습니다.'}},
                'FEDFUNDS': {'title': 'EFFR 금리', 'content': {'경제적 의미': 'Effective Federal Funds Rate는 은행들이 연준에 예치된 자금을 상호 대출할 때 적용되는 실제 금리를 의미합니다. 연준 기준 금리와 밀접하게 연관됩니다.', '왜 필요한 지표인가': 'EFFR은 연준의 통화 정책 방향을 보여주며, 경제 성장, 인플레이션, 고용에 영향을 미칩니다. 예를 들면, EFFR 금리가 높다는건, 은행간의 대출 부담을 높여서 시중에 빌리는 돈의 규모를 축소한다는 의미가 될 수 있습니다. 결과적으로 긴축 효과를 냅니다.'}},
                'TB3MS': {'title': '3개월 미 국채금리', 'content': {'경제적 의미': '3개월 만기 미국 재무부 증권의 수익률로, 단기 시장 금리와 인플레이션 기대치를 반영합니다.', '왜 필요한 지표인가': '단기 금리 동향을 파악하고, 경제 회복 또는 침체 신호를 분석하는 데 유용합니다. 금리가 상승한다는 의미는, 미국 정부가 국채 발행을 많이해서 원하는 곳에 돈을 많이 풀고 싶다는 간접적인 의미가 될 수 있고, 반대로 미국채 수요가 적어서 금리가 상승할 수 있습니다.'}},
                'TB1YR': {'title': '1년물 미 국채금리', 'content': {'경제적 의미': '1년 만기 미국 재무부 증권의 수익률로, 중단기 금리와 경제 전망을 반영합니다.', '왜 필요한 지표인가': '단기와 장기 금리 간 관계를 통해 경제 성장 기대치나 인플레이션 우려를 파악할 수 있어, 투자자와 정책 입안자에게 중요합니다. 또한 금리가 상승한다는 의미는, 미국 정부가 국채 발행을 많이해서 원하는 곳에 돈을 많이 풀고 싶다는 간접적인 의미가 될 수 있고, 반대로 미국채 수요가 적어서 금리가 상승할 수 있습니다.'}},
                'RRPONTSYD': {'title': '연준 역레포 자금', 'content': {'경제적 의미': 'Reverse Repurchase Agreement는 연준이 금융기관으로부터 자산을 매입하고 나중에 되팔며 유동성을 흡수하는 도구입니다. 이 금액은 시장의 잉여 자금을 보여줍니다.', '왜 필요한 지표인가': '연준이 금리를 통제하거나 유동성을 조절할 때 사용되며, 시장의 과도한 유동성(예: 인플레이션 위험)을 관리하는 데 필요합니다. 즉, 연레포 자금이 증가한다는 것은, 시중에 풀린 돈을 중앙은행에 묶어둔다는 뜻 입니다. 이렇게 되면 유동성이 긴축되어 시장의 주가가 감소할 수 있습니다.'}},
                'MMMFFAQ027S': {'title': 'MMF 잔고', 'content': {'경제적 의미': 'Money Market Fund의 총 자산 잔고로, 투자자들이 안전 자산에 얼마나 많은 자금을 넣는지 보여줍니다. 주로 기준금리가 높은 시기에 수익율이 높아서 몰리거나, 시장(주식) 가격이 불안정할 수 있다고 예상되면 MMF로 자금이 몰리게 됩니다.', '왜 필요한 지표인가': 'MMF 잔고는 투자 심리와 위험 회피 성향을 반영하며, 금융 시장 불확실성이 높을 때 증가하는 경향이 있어 경제 안정성 평가에 유용합니다.'}},
                'SP500': {'title': 'S&P500 지수', 'content': {'경제적 의미': '미국 500대 기업의 주식 성과를 종합한 지수로, 주식 시장의 전반적인 건강 상태를 나타냅니다.', '왜 필요한 지표인가': '경제 성장, 기업 수익, 투자자 신뢰를 반영하며, 소비자 지출과 연결되므로 거시경제 분석에 필수적입니다.'}},
                'DPCREDIT': {'title': '연준 할인율', 'content': {'경제적 의미': '연준이 상업 은행에 대출할 때 적용하는 이자율로, 금융기관의 자금 조달 비용을 결정합니다. 할인율이 낮게 되면, 연준이 시중 은행에 돈을 풀고 싶다는 의미가 될 수 있습니다.', '왜 필요한 지표인가': '은행의 유동성 지원과 신용 경색 방지에 사용되며, 연준의 긴급 통화 정책을 평가하는 데 중요합니다.'}},
                'DRBLACBS': {'title': '미 은행 연체율(전체)', 'content': {'경제적 의미': '은행 대출 중 연체된 비율로, 대출자의 상환 능력과 신용 위험을 나타냅니다.', '왜 필요한 지표인가': '경제 침체 신호나 금융 시스템의 건전성을 평가하며, 대출 정책과 규제 강화의 기초 자료로 사용됩니다.'}},
                'NASDAQ100': {'title': '나스닥100 지수', 'content': {'경제적 의미': '기술주 중심의 100개 기업 주가를 반영한 지수로, 기술 섹터의 성과를 보여줍니다.', '왜 필요한 지표인가': '기술 산업의 성장과 혁신을 반영하며, 글로벌 경제에서 기술 의존도가 높아짐에 따라 중요한 기준이 됩니다.'}},
                'WALCL': {'title': '연준 전체 자산 + 부채', 'content': {'경제적 의미': '연준의 총 자산(예: 채권 보유량)과 부채(예: 준비금)를 합친 금액으로, 연준의 재무 상태를 나타냅니다.', '왜 필요한 지표인가': '양적 완화나 긴축 정책의 규모를 보여주며, 연준의 통화 정책과 시장 유동성에 미치는 영향을 분석하는 데 필수적입니다.'}},
                'SP500_MCAP': {'title': 'S&P500 시가총액', 'content': {'경제적 의미': 'S&P500 지수에 포함된 기업들의 총 시가총액입니다. 이는 미국 주식 시장의 전반적인 규모와 가치를 나타내며, 경제의 전반적인 건전성과 투자 심리를 반영합니다.', '왜 필요한 지표인가': '주식 시장의 과열 또는 침체 여부를 판단하는 데 중요한 지표입니다. 시가총액의 증가는 경제 성장과 기업 수익성 개선을, 감소는 경기 둔화나 불확실성 증대를 시사할 수 있습니다.'}}
            }[indicator] || { title: indicator, content: { '경제적 의미': '정보 없음' } };

            document.getElementById('infoTitle').textContent = info.title || 'Unknown';
            document.getElementById('infoContent').innerHTML = Object.entries(info.content)
                .map(([key, value]) => `<p><strong>${key}:</strong> ${value}</p>`).join('');
        }

        async function updateLiquidityFlowAnimation() {
            stopLiquidityFlowAnimation();

            const displays = {
                tga: document.getElementById('tgaSlopeDisplay'),
                fed: document.getElementById('fedLiquidityDisplay'),
                mmf_fed: document.getElementById('mmfToRrpDisplay'),
                mmf_market: document.getElementById('mmfToMarketDisplay')
            };

            const updateDates = {
                tga: document.getElementById('tgaUpdateDate'),
                fed: document.getElementById('fedUpdateDate'),
                mmf_fed: document.getElementById('mmfFedUpdateDate'),
                mmf_market: document.getElementById('mmfMarketUpdateDate'),
            };

            const mmfMarketValues = document.getElementById('mmfMarketValues');

            Object.values(displays).forEach(el => {
                if(el) {
                    el.textContent = "계산 중...";
                    el.style.color = "black";
                }
            });

            const indicators = ['WTREGEN', 'WALCL', 'RRPONTSYD', 'WRESBAL', 'MMMFFAQ027S', 'MMF2RRP', 'MMF2MARKET', 'MMF2GOVERNMENT'];
            const dataStore = {};

            await Promise.all(indicators.map(async (indicator) => {
                try {
                    const response = await fetch(`${FUNCTION_BASE_URL}?indicator=${indicator}`);
                    if (!response.ok) throw new Error(`Status ${response.status}`);
                    const data = await parseCSV(await response.text());
                    dataStore[indicator] = data.length > 0 ? data.sort((a, b) => new Date(a.date) - new Date(b.date)) : [];
                } catch (error) {
                    console.error(`${indicator} 데이터 로드 실패:`, error.message);
                    dataStore[indicator] = [];
                }
            }));

            const getClosestPastDataValue = (data, targetDate) => {
                if (!data || data.length === 0) return null;
                const closestItem = data.filter(d => new Date(d.date) <= targetDate).pop();
                return closestItem ? closestItem.value : null;
            };

            const calculatedValues = [];

            const thirtyDaysAgo = (date) => {
                const newDate = new Date(date);
                newDate.setDate(newDate.getDate() - 30);
                return newDate;
            };

            // --- 모든 값 계산 ---
            let tgaDiff = null, fedLiquidityDiff = null, mmfToFedDiff = null, finalMmfToMarketDiff = null;
            let latestDate = null;
            let mmfToMarketCombined = null;
            let mmfAssetChange = null;

            // TGA, 연준 유동성
            if (['WTREGEN', 'WALCL', 'RRPONTSYD', 'WRESBAL'].every(i => dataStore[i] && dataStore[i].length > 0)) {
                latestDate = new Date(dataStore.WTREGEN[dataStore.WTREGEN.length - 1].date);
                const pastDate = thirtyDaysAgo(latestDate);
                const latest = { tga: getClosestPastDataValue(dataStore.WTREGEN, latestDate), walcl: getClosestPastDataValue(dataStore.WALCL, latestDate), rrp: getClosestPastDataValue(dataStore.RRPONTSYD, latestDate), resbal: getClosestPastDataValue(dataStore.WRESBAL, latestDate) };
                const past = { tga: getClosestPastDataValue(dataStore.WTREGEN, pastDate), walcl: getClosestPastDataValue(dataStore.WALCL, pastDate), rrp: getClosestPastDataValue(dataStore.RRPONTSYD, pastDate), resbal: getClosestPastDataValue(dataStore.WRESBAL, pastDate) };

                if (Object.values(latest).every(v => v !== null) && Object.values(past).every(v => v !== null)) {
                    tgaDiff = latest.tga - past.tga;
                    const walclDiff = (latest.walcl / 1000) - (past.walcl / 1000);
                    const otherDiffs = (latest.tga - past.tga) + 2 * (latest.rrp - past.rrp) + 2 * (latest.resbal - past.resbal);
                    fedLiquidityDiff = walclDiff - otherDiffs;
                }
            }

            // MMF -> FED
            if (dataStore.RRPONTSYD && dataStore.RRPONTSYD.length > 0) {
                 const latestDateRRP = new Date(dataStore.RRPONTSYD[dataStore.RRPONTSYD.length - 1].date);
                 const pastDateRRP = thirtyDaysAgo(latestDateRRP);
                 const latestVal = getClosestPastDataValue(dataStore.RRPONTSYD, latestDateRRP);
                 const pastVal = getClosestPastDataValue(dataStore.RRPONTSYD, pastDateRRP);
                 if (latestVal !== null && pastVal !== null) {
                     mmfToFedDiff = latestVal - pastVal; // 역레포 자금은 MMF에서 연준으로 흐르는 양을 보여주므로, RRP 변화량 자체가 MMF->FED 흐름임
                 }
                 if (!latestDate) latestDate = latestDateRRP;
            }

            // MMF -> 시장
            if (dataStore.MMF2MARKET?.length > 0 && dataStore.MMF2GOVERNMENT?.length > 0) {
                 const latestDateM = new Date(dataStore.MMF2MARKET[dataStore.MMF2MARKET.length - 1].date);
                 const pastDateM = thirtyDaysAgo(latestDateM);
                 const latestM = getClosestPastDataValue(dataStore.MMF2MARKET, latestDateM);
                 const pastM = getClosestPastDataValue(dataStore.MMF2MARKET, pastDateM);
                 
                 const latestDateG = new Date(dataStore.MMF2GOVERNMENT[dataStore.MMF2GOVERNMENT.length - 1].date);
                 const pastDateG = thirtyDaysAgo(latestDateG);
                 const latestG = getClosestPastDataValue(dataStore.MMF2GOVERNMENT, latestDateG);
                 const pastG = getClosestPastDataValue(dataStore.MMF2GOVERNMENT, pastDateG);

                 if(latestM !== null && pastM !== null && latestG !== null && pastG !== null) {
                    mmfToMarketCombined = ((latestM - pastM) / 1e9) + ((latestG - pastG) / 1e9);
                 }
                 if (!latestDate) latestDate = latestDateM;
            }
            
            if(dataStore.MMMFFAQ027S?.length > 0) {
                const latestDateMMF = new Date(dataStore.MMMFFAQ027S[dataStore.MMMFFAQ027S.length-1].date);
                const pastDateMMF = thirtyDaysAgo(latestDateMMF);
                const latestVal = getClosestPastDataValue(dataStore.MMMFFAQ027S, latestDateMMF);
                const pastVal = getClosestPastDataValue(dataStore.MMMFFAQ027S, pastDateMMF);
                if(latestVal !== null && pastVal !== null){
                    mmfAssetChange = (latestVal - pastVal) / 1e9; // 단위 Billions로
                }
                if (!latestDate) latestDate = latestDateMMF;
            }

            if (mmfToMarketCombined !== null && mmfAssetChange !== null) {
                finalMmfToMarketDiff = mmfAssetChange - mmfToMarketCombined; // MMF자산 변화량 - MMF의 시장 공급
            }
            
            const formatDate = (date) => date ? `Update Date: ${date.toISOString().slice(0, 10)}` : '';
            const sign = (value) => value > 0 ? '+' : '';

            // 계산된 값들을 배열에 추가
            if (tgaDiff !== null) {
                 calculatedValues.push({ value: tgaDiff, element: displays.tga, label: 'TGA 잔고:', animationClass: tgaDiff < 0 ? 'animated-dollar-from-government' : 'animated-dollar-to-government' });
                 updateDates.tga.textContent = formatDate(latestDate);
            }
            if (fedLiquidityDiff !== null) {
                 calculatedValues.push({ value: fedLiquidityDiff, element: displays.fed, label: '연준 유동성:', animationClass: fedLiquidityDiff < 0 ? 'animated-dollar-to-fed' : 'animated-dollar-to-market' });
                 updateDates.fed.textContent = formatDate(latestDate);
            }
            if (mmfToFedDiff !== null) {
                 calculatedValues.push({ value: mmfToFedDiff, element: displays.mmf_fed, label: 'MMF -> FED:', animationClass: mmfToFedDiff >= 0 ? 'animated-dollar-from-mmf-to-fed' : 'animated-dollar-from-fed-to-mmf' });
                 updateDates.mmf_fed.textContent = formatDate(latestDate);
            }
            if (finalMmfToMarketDiff !== null) {
                 calculatedValues.push({ value: finalMmfToMarketDiff, element: displays.mmf_market, label: 'MMF ->시장:', animationClass: finalMmfToMarketDiff > 0 ? 'animated-dollar-from-mmf-to-market_parabolic' : 'animated-dollar-from-market-to-mmf_parabolic' });
                 updateDates.mmf_market.textContent = formatDate(latestDate);
                 if (mmfToMarketCombined !== null && mmfAssetChange !== null) {
                     mmfMarketValues.innerHTML = `MMF의 시장 유동성 공급 변화량 = ${sign(mmfToMarketCombined)}${mmfToMarketCombined.toFixed(2)} B $/Month<br>시장의 MMF 투자 변화량 = ${sign(mmfAssetChange)}${mmfAssetChange.toFixed(2)} B $/Month`;
                 }
            }
            

            // 절대값 기준으로 순위 매기기
            const rankedAnimations = calculatedValues.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
            
            // 텍스트 표시
            rankedAnimations.forEach(({ value, element, label }) => {
                if (element) {
                    const sign = value > 0 ? '+' : '';
                    element.innerHTML = `${label}<br>${sign}${value.toFixed(2)} B $/Month`;
                    element.className = value > 0 ? 'slope-positive' : 'slope-negative';
                }
            });

            // 애니메이션 실행
            const startAnimations = () => {
                rankedAnimations.forEach((task, index) => {
                    const factor = (4 - index) / 4.0;
                    if (factor <= 0) return;

                    const size = BASE_DOLLAR_SIZE * factor;
                    const duration = BASE_ANIMATION_DURATION / factor; // 속도는 배율에 반비례
                    const spawnInterval = duration / NUM_DOLLAR_ANIMATIONS;

                    for (let i = 0; i < NUM_DOLLAR_ANIMATIONS; i++) {
                        const delay = i * spawnInterval;
                        const timeoutId = setTimeout(() => {
                            createAndAnimateDollar(task.animationClass, size, duration);
                        }, delay);
                        dollarAnimationIntervals.push(timeoutId);
                    }
                });
            };

            if (rankedAnimations.length > 0) {
                startAnimations();
                const resetIntervalId = setInterval(startAnimations, BASE_ANIMATION_DURATION);
                dollarAnimationIntervals.push(resetIntervalId);
            }
        }
        
        function createAndAnimateDollar(animationClass, size, duration) {
            const dollar = document.createElement('img');
            dollar.src = "./icon/dollar.jpg";
            dollar.alt = "Dollar";
            dollar.className = 'dollar-animated-object';
            dollar.style.width = `${size}px`;
            dollar.style.height = `${size}px`;
            dollar.style.setProperty('--animation-duration', `${duration / 1000}s`);
            dollar.classList.add(animationClass);
            
            document.getElementById('liquidityFlow').appendChild(dollar);
            dollar.addEventListener('animationend', () => dollar.remove());
        }

        function stopLiquidityFlowAnimation() {
            dollarAnimationIntervals.forEach(id => clearTimeout(id));
            dollarAnimationIntervals.forEach(id => clearInterval(id));
            dollarAnimationIntervals = [];
            document.querySelectorAll('.dollar-animated-object').forEach(el => el.remove());
        }

        function startDragging(e) { if(myChart) { isDragging = true; startX = e.pageX - e.target.getBoundingClientRect().left; startScrollX = myChart.options.scales.x.min; e.target.style.cursor = 'grabbing'; }}
        function drag(e) {
            if (!isDragging || !myChart) return;
            e.preventDefault();
            const { x } = myChart.scales;
            const dataRange = x.max - x.min;
            const pixelRange = myChart.chartArea.right - myChart.chartArea.left;
            if (pixelRange <= 0) return;

            const dataOffset = ((e.pageX - e.target.getBoundingClientRect().left - startX) * 0.6 / pixelRange) * dataRange;
            let newMin = startScrollX - dataOffset;
            let newMax = newMin + dataRange;

            const allDates = currentGraphData.map(d => new Date(d.date).getTime());
            const minAllowed = Math.min(...allDates);
            const maxAllowed = Math.max(...allDates);

            if (newMin < minAllowed) { newMin = minAllowed; newMax = newMin + dataRange; }
            if (newMax > maxAllowed) { newMax = maxAllowed; newMin = newMax - dataRange; }

            myChart.options.scales.x.min = newMin;
            myChart.options.scales.x.max = newMax;
            myChart.update('none');
        }
        function stopDragging(e) { if(isDragging) { isDragging = false; e.target.style.cursor = 'grab'; }}
        function zoomChart(e) {
            if (!myChart) return;
            e.preventDefault();
            const { x } = myChart.scales;
            const { min, max } = x;
            const range = max - min;
            const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
            const mouseX = e.offsetX;
            const center = x.getValueForPixel(mouseX);
            
            const newMin = center - (center - min) * zoomFactor;
            const newMax = center + (max - center) * zoomFactor;

            const allDates = currentGraphData.map(d => new Date(d.date).getTime());
            const minAllowed = Math.min(...allDates);
            const maxAllowed = Math.max(...allDates);

            if (newMin >= minAllowed && newMax <= maxAllowed) {
                myChart.options.scales.x.min = newMin;
                myChart.options.scales.x.max = newMax;
                myChart.update('none');
            }
        }
        function goBackToGraph() { if (currentIndicator && myChart) { showPage('graphPage'); updateChart('All'); } }

    </script>
</body>
</html>