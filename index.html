<!DOCTYPE html>
<html>
<head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquidity Dashboard</title>
    <style>
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0; background: #f0f2f5; color: #333; }
        .container { max-width: 1200px; margin: auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        #liquidityFlow, #graphView { display: none; }
        #graphView { width: 100%; height: 500px; }
        .back-btn { position: absolute; top: 20px; left: 20px; background: #e4e6eb; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px; line-height: 40px; text-align: center; }
        .back-btn:hover { background: #dcdde1; }
        .info-btn { position: absolute; top: 20px; right: 20px; background: #e4e6eb; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px; line-height: 40px; text-align: center; }
        .info-btn:hover { background: #dcdde1; }
        .flow-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; align-items: center; text-align: center; }
        .flow-item { display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .flow-item img { width: 80px; height: 80px; }
        .flow-item .label, .flow-item .value, #net-liquidity-value { font-weight: bold; font-size: 1.1em; }
        .arrow { font-size: 2.5em; color: #007bff; position: relative; }
        .popup { visibility: hidden; width: 280px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -140px; opacity: 0; transition: opacity 0.3s; }
        .popup::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }
        .flow-item:hover .popup { visibility: visible; opacity: 1; }
        #dollar-icon { position: absolute; width: 25px; height: 25px; transition: all 1s ease-in-out; }
        .graph-title { font-size: 1.5em; font-weight: bold; margin-bottom: 15px; }
        .button { padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px; }
        .button:hover { background: #0056b3; }
        canvas { cursor: grab; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>

<div class="container">
    <div id="mainView">
        <div class="header">
            <h1>유동성 대시보드</h1>
        </div>
        <button class="button" onclick="showLiquidityFlow()">유동성 흐름</button>
        <button class="button" onclick="showGraph('WTREGEN')">TGA 잔고</button>
        <button class="button" onclick="showGraph('WRESBAL')">지준 잔고</button>
        <button class="button" onclick="showGraph('WALCL')">연준 총자산</button>
        <button class="button" onclick="showGraph('RRPONTSYD')">MMF 잔고</button>
    </div>

    <div id="liquidityFlow">
        <button class="back-btn" onclick="showMainView()">&#9664;</button>
        <button class="info-btn">i</button>
        <div class="header">
            <h2>유동성 흐름</h2>
        </div>
        <div class="flow-grid">
            <div class="flow-item" id="fed-item">
                <img src="http://googleusercontent.com/file_content/2" alt="Fed">
                <p class="label" onmouseover="showPopup('fed-popup')" onmouseout="hidePopup('fed-popup')">연준 유동성: <span id="fed-value" class="value"></span></p>
                <div class="popup" id="fed-popup">연준 자산 변화량 = <span id="fed-popup-value"></span></div>
            </div>
            <div class="arrow" id="fed-to-market-arrow">&#10230;</div>
            <div class="flow-item" id="market-item">
                <img src="http://googleusercontent.com/file_content/0" alt="Market">
                <p class="label">미국 시장</p>
                <p id="net-liquidity-value"></p>
            </div>

            <div class="flow-item" id="tga-item">
                <img src="http://googleusercontent.com/file_content/3" alt="TGA">
                <p class="label" onmouseover="showPopup('tga-popup')" onmouseout="hidePopup('tga-popup')">TGA 잔고: <span id="tga-value" class="value"></span></p>
                <div class="popup" id="tga-popup">TGA 계좌 변화량 = <span id="tga-popup-value"></span></div>
            </div>
            <div class="arrow" id="tga-to-market-arrow">&#10230;</div>
            <div></div> 

            <div class="flow-item" id="mmf-item">
                <img src="http://googleusercontent.com/file_content/1" alt="MMF">
                <p class="label" onmouseover="showPopup('mmf-popup')" onmouseout="hidePopup('mmf-popup')">MMF -&gt;시장: <span id="mmf-value" class="value"></span></p>
                 <div class="popup" id="mmf-popup">
                    시장의 MMF 투자 변화량 = <span id="mmf-popup-value"></span>
                    <br>
                    <button class="button" onclick="showGraph('RRPONTSYD')">그래프</button>
                </div>
            </div>
            <div class="arrow" id="mmf-to-market-arrow">&#10230;</div>
            <div></div> 
        </div>
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Dollar_Sign.svg/240px-Dollar_Sign.svg.png" id="dollar-icon" alt="dollar">
    </div>

    <div id="graphView">
        <button class="back-btn" onclick="goBackToPreviousView()">&#9664;</button>
        <div id="graph-container" style="position: relative; height: 500px; width: 100%;">
            <canvas id="myChart"></canvas>
        </div>
    </div>
</div>

<script>
    let myChart;
    let currentGraph = '';
    let previousView = 'main';
    let allData = {};
    let isDragging = false;
    let dragStartX;
    let currentGraphData = [];

    // --- 1번 요청: 계산 로직 수정을 위한 핵심 함수 ---
    // 여러 데이터셋에서 공통된 가장 최신 날짜를 찾는 함수
    function findLatestCommonDate(datasets) {
        if (datasets.length === 0) return null;

        // 각 데이터셋의 날짜를 Set으로 변환
        const dateSets = datasets.map(data => new Set(data.map(d => d.date)));

        // 모든 Set의 교집합(intersection)을 찾음
        let commonDates = new Set(dateSets[0]);
        for (let i = 1; i < dateSets.length; i++) {
            commonDates = new Set([...commonDates].filter(date => dateSets[i].has(date)));
        }

        if (commonDates.size === 0) return null;

        // 공통된 날짜 중 가장 최신 날짜 반환
        return new Date(Math.max(...[...commonDates].map(date => new Date(date))));
    }

    // 월별 변화량 계산 함수 (수정됨)
    function calculateMonthlyChange(data, latestCommonDate) {
        if (!data || data.length < 2 || !latestCommonDate) {
            return { latestValue: 'N/A', change: 'N/A' };
        }
        
        const endDate = new Date(latestCommonDate);
        const startDate = new Date(endDate);
        startDate.setMonth(startDate.getMonth() - 1);

        const findClosestData = (targetDate) => {
            return data.reduce((prev, curr) => {
                const prevDiff = Math.abs(new Date(prev.date) - targetDate);
                const currDiff = Math.abs(new Date(curr.date) - targetDate);
                return currDiff < prevDiff ? curr : prev;
            });
        };
        
        const latestData = findClosestData(endDate);
        const previousData = findClosestData(startDate);

        if (!latestData || !previousData) {
            return { latestValue: 'N/A', change: 'N/A' };
        }

        const latestValue = parseFloat(latestData.value);
        const previousValue = parseFloat(previousData.value);
        const change = (latestValue - previousValue) / 1000; // B 단위로 변환
        
        return { latestValue: latestValue, change: change };
    }

    async function loadAllData() {
        const files = ['WTREGEN', 'WRESBAL', 'WALCL', 'RRPONTSYD'];
        for (const file of files) {
            try {
                const response = await fetch(`${file}.csv`);
                const text = await response.text();
                const lines = text.trim().split('\n');
                const header = lines.shift().trim().split(',');
                allData[file] = lines.map(line => {
                    const values = line.trim().split(',');
                    return { date: values[0], value: parseFloat(values[1]) };
                }).filter(d => d.date && !isNaN(d.value)); // 유효한 데이터만 필터링
            } catch (error) {
                console.error(`Error loading ${file}.csv:`, error);
            }
        }
        processDataForLiquidityFlow();
    }
    
    // 유동성 흐름 데이터 처리 및 UI 업데이트 함수 (수정됨)
    function processDataForLiquidityFlow() {
        // --- 1번 요청: 공통 최신 날짜를 찾는 로직 적용 ---
        const datasetsForCommonDate = [allData.WALCL, allData.WRESBAL, allData.WTREGEN, allData.RRPONTSYD];
        const latestCommonDate = findLatestCommonDate(datasetsForCommonDate.filter(d => d)); // 로드된 데이터만 사용

        if (!latestCommonDate) {
            console.error("Could not find a common date across datasets.");
            return;
        }

        // 연준 유동성 (WALCL - WRESBAL)
        const combinedFedData = allData.WALCL.map(walcl => {
            const wresbal = allData.WRESBAL.find(d => d.date === walcl.date);
            if (wresbal) {
                return { date: walcl.date, value: walcl.value - wresbal.value };
            }
            return null;
        }).filter(Boolean);

        const fedResult = calculateMonthlyChange(combinedFedData, latestCommonDate);
        const tgaResult = calculateMonthlyChange(allData.WTREGEN, latestCommonDate);
        const mmfResult = calculateMonthlyChange(allData.RRPONTSYD, latestCommonDate);
        
        // MMF는 시장으로 유입될 때 + 이므로 부호 반전
        const mmfChange = mmfResult.change * -1; 

        updateLiquidityUI('fed', fedResult.change);
        updateLiquidityUI('tga', tgaResult.change);
        updateLiquidityUI('mmf', mmfChange);

        // --- 3번 요청: 최종 합산 금액 계산 및 표시 ---
        updateNetLiquidity(fedResult.change, tgaResult.change, mmfChange);
        setupAnimations(fedResult.change, tgaResult.change, mmfChange);
    }

    function updateLiquidityUI(type, value) {
        const valueEl = document.getElementById(`${type}-value`);
        const popupValueEl = document.getElementById(`${type}-popup-value`);
        
        if (valueEl && popupValueEl) {
            const sign = value >= 0 ? '+' : '';
            const color = value >= 0 ? 'red' : 'blue';
            const formattedValue = `${sign}${value.toFixed(2)} B $/Month`;
            
            valueEl.textContent = formattedValue;
            valueEl.style.color = color;
            popupValueEl.textContent = formattedValue;
            popupValueEl.style.color = color;
        }
    }
    
    // --- 3번 요청: 최종 계산 결과 표시를 위한 함수 ---
    function updateNetLiquidity(fed, tga, mmf) {
        const netValue = fed - tga - mmf;
        const netValueEl = document.getElementById('net-liquidity-value');
        if (netValueEl) {
            const sign = netValue >= 0 ? '+' : '';
            const color = netValue >= 0 ? 'red' : 'blue';
            netValueEl.innerHTML = `${sign}${netValue.toFixed(2)} B $/Month`;
            netValueEl.style.color = color;
        }
    }

    function setupAnimations(fed, tga, mmf) {
        const dollarIcon = document.getElementById('dollar-icon');
        const fedItem = document.getElementById('fed-item').getBoundingClientRect();
        const marketItem = document.getElementById('market-item').getBoundingClientRect();
        const tgaItem = document.getElementById('tga-item').getBoundingClientRect();
        const mmfItem = document.getElementById('mmf-item').getBoundingClientRect();

        const animate = (startEl, endEl, value) => {
            if (value === 0) return;
            const dir = value > 0 ? 1 : -1;
            const startX = startEl.left + startEl.width / 2 - dollarIcon.width / 2;
            const startY = startEl.top + startEl.height / 2 - dollarIcon.height / 2;
            const endX = endEl.left + endEl.width / 2 - dollarIcon.width / 2;
            const endY = endEl.top + endEl.height / 2 - dollarIcon.height / 2;

            dollarIcon.style.opacity = '1';
            if (dir > 0) { // start -> end
                dollarIcon.style.left = `${startX}px`;
                dollarIcon.style.top = `${startY}px`;
                setTimeout(() => {
                    dollarIcon.style.left = `${endX}px`;
                    dollarIcon.style.top = `${endY}px`;
                }, 100);
            } else { // end -> start
                dollarIcon.style.left = `${endX}px`;
                dollarIcon.style.top = `${endY}px`;
                setTimeout(() => {
                    dollarIcon.style.left = `${startX}px`;
                    dollarIcon.style.top = `${startY}px`;
                }, 100);
            }
        };

        // This is a simplified animation cycle. A real implementation might queue these.
        setTimeout(() => animate(fedItem, marketItem, fed), 0);
        setTimeout(() => animate(marketItem, tgaItem, tga), 2000); // TGA is market -> TGA
        setTimeout(() => animate(mmfItem, marketItem, mmf), 4000); // MMF is MMF -> market
    }

    function showPopup(id) { document.getElementById(id).style.visibility = 'visible'; }
    function hidePopup(id) { document.getElementById(id).style.visibility = 'hidden'; }

    function showView(viewId) {
        document.getElementById('mainView').style.display = 'none';
        document.getElementById('liquidityFlow').style.display = 'none';
        document.getElementById('graphView').style.display = 'none';
        document.getElementById(viewId).style.display = 'block';
    }

    function showMainView() {
        previousView = 'main';
        showView('mainView');
    }

    function showLiquidityFlow() {
        previousView = 'main';
        showView('liquidityFlow');
        document.getElementById('liquidityFlow').style.display = 'block'; // Make sure grid displays correctly
        processDataForLiquidityFlow(); // Recalculate and update UI
    }

    function goBackToPreviousView() {
        if (previousView === 'liquidity') {
            showLiquidityFlow();
        } else {
            showMainView();
        }
    }
    
    function showGraph(graphName) {
        currentGraph = graphName;
        previousView = document.getElementById('liquidityFlow').style.display === 'block' ? 'liquidity' : 'main';
        showView('graphView');
        renderGraph(graphName);
    }
    
    function renderGraph(graphName) {
        currentGraphData = allData[graphName].map(d => ({ x: new Date(d.date), y: d.value }));
        const ctx = document.getElementById('myChart').getContext('2d');
        const canvas = document.getElementById('myChart');

        if (myChart) {
            myChart.destroy();
        }

        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: graphName,
                    data: currentGraphData,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'month' },
                        title: { display: true, text: 'Date' }
                    },
                    y: {
                        title: { display: true, text: 'Value' }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `${graphName} Trend`,
                        font: { size: 18 }
                    }
                }
            }
        });
        
        // Drag and Zoom functionality
        canvas.addEventListener('mousedown', startDragging);
        canvas.addEventListener('mousemove', dragChart);
        canvas.addEventListener('mouseup', stopDragging);
        canvas.addEventListener('mouseleave', stopDragging);
        canvas.addEventListener('wheel', zoomChart);
    }
    
    function startDragging(e) {
        isDragging = true;
        dragStartX = e.clientX;
        e.target.style.cursor = 'grabbing';
    }

    function dragChart(e) {
        if (!isDragging || !myChart) return;
        const { min, max } = myChart.options.scales.x;
        const dataRange = max - min;
        const chartWidth = e.target.width;
        
        const delta = (dragStartX - e.clientX) * (dataRange / chartWidth);
        dragStartX = e.clientX;

        const allDates = currentGraphData.map(d => new Date(d.x).getTime());
        const minAllowed = Math.min(...allDates);
        const maxAllowed = Math.max(...allDates);

        let newMin = min + delta;
        let newMax = max + delta;

        if (newMin < minAllowed) { newMin = minAllowed; newMax = newMin + dataRange; }
        if (newMax > maxAllowed) { newMax = maxAllowed; newMin = newMax - dataRange; }

        myChart.options.scales.x.min = newMin;
        myChart.options.scales.x.max = newMax;
        myChart.update('none');
    }

    function stopDragging(e) {
        if (isDragging) {
            isDragging = false;
            e.target.style.cursor = 'grab';
        }
    }

    function zoomChart(e) {
        if (!myChart) return;
        e.preventDefault();
        const { x } = myChart.scales;
        const { min, max } = x;
        const range = max - min;
        const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
        const mouseX = e.offsetX;
        const center = x.getValueForPixel(mouseX);
        
        let newMin = center - (center - min) * zoomFactor;
        let newMax = center + (max - center) * zoomFactor;

        const allDates = currentGraphData.map(d => new Date(d.x).getTime());
        const minAllowed = Math.min(...allDates);
        const maxAllowed = Math.max(...allDates);

        if (newMin >= minAllowed && newMax <= maxAllowed) {
            myChart.options.scales.x.min = newMin;
            myChart.options.scales.x.max = newMax;
            myChart.update('none');
        }
    }

    // Initial load
    window.onload = () => {
        showMainView();
        loadAllData();
    };
</script>
</body>
</html>